"""Models for PDF module"""

from datetime import datetime

from django.conf import settings
from django.core.validators import MinValueValidator
from django.db.models import (
    Model,
    DateTimeField,
    IntegerField,
    CharField,
    TextChoices,
    ManyToManyField,
    ForeignKey,
    CASCADE,
    CheckConstraint,
    Q,
    PositiveIntegerField,
    BooleanField,
    ImageField,
    FloatField,
)
from django.utils.text import slugify
from django.utils.translation import gettext_lazy as _

from pdf.storage import DateOverwriteStorage
from tenants.models import Tenant

fs = DateOverwriteStorage()


class RequestType(TextChoices):
    """Type of PDF Request"""

    EVENT = "EV", _("Automated")
    MANUAL = "MA", _("Manual")


class Status(TextChoices):
    """Status of PDF Request"""

    QUEUED = "QU", _("Queued")
    SCHEDULED = "SC", _("Scheduled")
    IN_PROGRESS = "PR", _("In progress")
    DONE = "DO", _("Done")
    FAILED = "FA", _("Failed")


def upload_path(instance, filename):
    """Returns upload path for this request"""
    return datetime.now().strftime(f"pdfs/{instance.tenant_id}/%y%m%d/{filename}")


class PDFRequest(Model):
    """Request for PDF generation"""

    filename = CharField(
        max_length=30,
        blank=True,
        help_text=_("Filename of the generated PDF, please do not include .pdf"),
        verbose_name=_("File name"),
    )
    public = BooleanField(
        default=True,
        help_text=_("True, if the file should be public"),
        verbose_name=_("Public file"),
    )
    locale = CharField(
        choices=settings.LANGUAGES,
        verbose_name=_("Language"),
        max_length=5,
        help_text=_("Language to be used in the generated PDF"),
    )
    title = CharField(
        max_length=100,
        blank=True,
        help_text=_("Name to be used on the title page of the PDF"),
        verbose_name=_("Title"),
    )
    show_date = BooleanField(
        default=True,
        verbose_name=_("Show date"),
        help_text=_("True, if the date should be included in the final PDF"),
    )
    image = ImageField(
        verbose_name=_("Title Image"),
        help_text=_("Optional title image of the songbook"),
        null=True,
        blank=True,
        upload_to="uploads/",
    )
    margin = FloatField(
        verbose_name=_("Title Image margins"),
        help_text=_("Margins for title image, might be needed for some printers"),
        default=0,
    )
    link = CharField(
        max_length=300,
        blank=True,
        help_text=_("Link to include in the PDF"),
        verbose_name=_("Link"),
    )

    tenant = ForeignKey(Tenant, on_delete=CASCADE, null=True)
    # update_date = DateTimeField(auto_now=True)
    type = CharField(
        max_length=2,
        choices=RequestType.choices,
        default=RequestType.EVENT,
    )
    status = CharField(max_length=2, choices=Status.choices, default=Status.QUEUED)
    last_generated = DateTimeField(null=True)
    # time_elapsed = IntegerField(null=True)
    progress = IntegerField(default=0)
    # file = FileField(null=True, storage=fs, upload_to=upload_path)
    songs = ManyToManyField("backend.Song", through="PDFSong")
    scheduled_at = DateTimeField(null=True)

    # pylint: disable=no-member
    def get_tenant(self):
        """Returns real tenant of the request"""
        if self.category:
            return self.category.tenant
        return self.tenant

    def get_song_pairs(self):
        """Returns all song pairs (tuple[Song, int] for request"""
        if self.category:
            return get_category_songs(self.category)
        return [pdf_song.get_song() for pdf_song in self.pdfsong_set.all()]

    def get_title(self):
        """Returns title to use for this request"""
        if self.title:
            return self.title
        if self.category:
            return self.category.name
        return self.tenant.name

    def get_filename(self):
        """Returns filename of the file generated by this request"""
        if self.filename:
            return self.filename
        return slugify(self.get_title())

    def get_latest(self):
        """Returns latest file generated with this request"""
        if self.pdffile_set.exists():
            return self.pdffile_set.order_by("-generated").first()
        return None

    class Meta:
        verbose_name = _("PDFRequest")
        verbose_name_plural = _("PDFRequests")
        constraints = [
            CheckConstraint(
                check=(Q(type=RequestType.MANUAL) & Q(tenant__isnull=False))
                | (Q(type=RequestType.EVENT) & Q(tenant__isnull=True)),
                name="has_tenant",
            ),
        ]
        ordering = ["-last_generated"]


def get_category_songs(category: "Category"):
    """Return all songs in a Category in a tuple[Song, int] format"""
    songs = []
    for song_number, song in enumerate(category.song_set.filter(archived=False).all()):
        songs.append((song, song_number))
    return songs


class PDFSong(Model):
    """Through table for PDFRequest and Song"""

    song = ForeignKey("backend.Song", on_delete=CASCADE)
    request = ForeignKey(PDFRequest, on_delete=CASCADE)
    song_number = PositiveIntegerField(validators=[MinValueValidator(1)], verbose_name=_("Song number"))

    class Meta:
        unique_together = ["song_number", "request", "song"]

    def get_song_pair(self):
        """Mapping function that maps PDFSong into tuple[Song, int]"""
        return self.song, self.song_number
